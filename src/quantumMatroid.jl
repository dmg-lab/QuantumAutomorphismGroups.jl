using Oscar
using Oscar.AbstractAlgebra
using Oscar.AbstractAlgebra.Generic

include("./utils.jl")
include("./multiSetMatroid.jl")
include("./save.jl")

export isInIdeal,
    generateSameIdeal,
    isCommutative,
    isCommutativeExtra,
    getMatroidRelations

@doc raw"""

    isInIdeal(element::FreeAssAlgElem{T}, I::Oscar.FreeAssAlgIdeal{<:FreeAssAlgElem{T}}, n::Int=3)

Wrapper for the function ideal_membership from Oscar. Checks if an element is in an ideal.

# Examples
```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
I = ideal(Ax,[x1^2+x2,x2^2+x3,x3])
isInIdeal(x1^2+x2,I)

# output

true
```
"""
function isInIdeal(ele::FreeAssAlgElem{T}, I::Oscar.FreeAssAlgIdeal{<:FreeAssAlgElem{T}},n::Int=3) where T<:FieldElem
        return ideal_membership(ele,I,n)
end

@doc raw"""

    isInIdeal(element::FreeAssAlgElem{T}, I::Vector{<:FreeAssAlgElem{T}}, n::Int=3)

Uses non-commutative groebner_basis from AbstractAlgebra to check if an element is in an ideal, by checking if the normal form is zero.

# Examples
```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
V = [x1^2+x2,x2^2+x3,x3]
isInIdeal(x1^2+x2,V)

# output

true
```
"""
function isInIdeal(ele::FreeAssAlgElem{T}, gb::Vector{<:FreeAssAlgElem{T}}) where T<:FieldElem
    nrm = normal_form(ele,gb)
    return iszero(nrm) 
end

@doc raw"""

    isInIdeal(gens1::Vector{<:FreeAssAlgElem{T}}, gens2::Vector{<:FreeAssAlgElem{T}}, alt::Bool=false, n::Int=3)

Checks if the first set of generators is in the ideal generated by the second set of generators. If alt is true, it uses the ideal_membership function instead.

# Examples
```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
V1 = [x1^2+x2,x2^2+x3,x3]
V2 = [V1...,x1^2+x3] 
isInIdeal(V1,V2) & !isInIdeal(V2,V1)

# output

true
```
"""
function isInIdeal(gens1::Vector{<:FreeAssAlgElem{T}}, gens2::Vector{<:FreeAssAlgElem{T}}, alt::Bool=false, n::Int=3) where T <:FieldElem
    if alt
        I=AbstractAlgebra.ideal(parent(gens2[1]),gens2)
        foreach(ele->isInIdeal(ele,I,n) || return false, gens1)        
    else
        for ele in gens1 
            isInIdeal(ele,gens2) || return false
        end
    end
    return true
end

@doc raw"""

    generateSameIdeal(gens1::Vector{<:FreeAssAlgElem{T}}, gens2::Vector{<:FreeAssAlgElem{T}}, alt::Bool=false, n::Int=3)

Checks if the first set of generators is in the ideal generated by the second set of generators and vice versa. If alt is true, it uses the ideal_membership function instead.

# Examples
```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
V1 = [x1^2+x2,x2^2+x3,x3]
V2 = [V1...,x1^2+x3]
generateSameIdeal(V1,V1) & !generateSameIdeal(V1,V2)

# output

true
```
"""
function generateSameIdeal(gens1::Vector{<:FreeAssAlgElem{T}}, gens2::Vector{<:FreeAssAlgElem{T}}; alt::Bool=false, n::Int=3) where T <:FieldElem
    isInIdeal(gens1, gens2, alt, n) || return false
    isInIdeal(gens2, gens1, alt, n) || return false
    return true
end

@doc raw"""

    isCommutative(I::Vector{<:FreeAssAlgElem{T}}, all::Bool = true)

Check if the quotient algebra is commutative. If all is false, it returns as soon as it finds a non-commutative element. Else it checks every pair of elements. 

!!! note
    Warning!! This is specialized for subalgebras of the quantum permutation group.
    It will not work in the general case.


# Examples

```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
V = [x1*x2-x2*x1,x2*x3-x3*x2,x1*x3-x3*x1]
isCommutative(V)

# output

true
```
"""
function isCommutative(I::Vector{<:FreeAssAlgElem{T}}, all::Bool = true) where T <: FieldElem

    Alg = parent(I[1])
    m = ngens(Alg)
    size = Int(floor(sqrt(m)))
    nCDict = Dict{FreeAssAlgElem,Bool}() # true means is in ideal, false means not in ideal
    c = true

    for i in 1:m-1, j in i+1:m
        tst = Alg[i]*Alg[j] - Alg[j]*Alg[i]

        j % size == i % size && continue
        div(i-1,size) == div(j-1,size) && continue
        if !isInIdeal(tst,I)
            nCDict[tst] = false
            all || return false, nCDict
            c = false
            continue
        end
        nCDict[tst] = true
    end
    return c, nCDict
end

@doc raw"""

    isCommutative(M::Matroid, structure::Symbol = :bases, alt::Bool = false, n::Int = 3)

Check if the quantum automorphism group of a matroid is commutative for a given structure. If alt is true, it uses the ideal_membership for faster yet incomplete computation.

!!! note
    Warning!! This is specialized for subalgebras of the quantum permutation group.
    It will not work in the general case.

# Examples

```jldoctest
M = uniform_matroid(3,4)
answer, _  = isCommutative(M,:bases)
answer

# output

true
```
"""
function isCommutative(M::Matroid, structure::Symbol = :bases, alt::Bool = false, n::Int = 3)
    relsToAdd, _, A = getMatroidRelations(M,structure)
    if alt
        I = Oscar.ideal(A,relsToAdd)
        return isCommutative(I)
    end
    gb = AbstractAlgebra.groebner_basis(relsToAdd)
    return isCommutative(gb)
end

@doc raw"""

    isCommutativeExtra(I::Vector{<:FreeAssAlgElem{T}}, all::Bool = false)

Check if the quotient algebra is commutative. Similar to isCommutative, but it also checks for some extra relations.

# Examples

```jldoctest
Ax,(x1,x2,x3) = FreeAssociativeAlgebra(QQ, ["x1","x2","x3"])
V = [x1*x2-x2*x1,x2*x3-x3*x2,x1*x3-x3*x1]
ans, _ = isCommutativeExtra(V)

# output

true
```
"""
function isCommutativeExtra(I::Vector{<:FreeAssAlgElem{T}}, all::Bool = false) where T <: FieldElem
    Alg = parent(I[1])
    m = ngens(Alg)
    size = Int(floor(sqrt(m)))

    nCDict = Dict{FreeAssAlgElem,Bool}() # true means is in ideal, false means not in ideal
    c = true

    for i in 1:m-1, j in i+1:m
        tst = Alg[i]*Alg[j] - Alg[j]*Alg[i]

        j % size == i % size && continue
        div(i-1,size) == div(j-1,size) && continue

        if !isInIdeal(tst,I)
            nCDict[tst] = false
            tst2 = Alg[i]*Alg[j] - Alg[j]*Alg[i]*Alg[j]
            if !isInIdeal(tst2,I)
                nCDict[tst2] = false
                all || return false, nCDict
                c = false
                continue
            end
        end
        nCDict[tst] = true
    end
    return c, nCDict
end

@doc raw"""

    getMatroidRelations(M::MultiSetMatroid, structure::Symbol=:bases, interreduce::Bool=false)

Get the relations that define the quantum automorphism group of a matroid for a given structure. If interreduce is true, it uses the interreduce function from Oscar to reduce the number of generators.

# Examples

```jldoctest
M = uniform_matroid(3,4)
rels, _, _ = getMatroidRelations(M,:bases)
typeof(rels)
# output

Vector{FreeAssAlgElem{QQFieldElem}}
```
"""
function getMatroidRelations(
    M::MultiSetMatroid,
    structure::Symbol=:bases,
    interreduce::Bool=false)
    
    relation_indices = getRelations(M,structure)
    relation_transformed,  u, A = getQuantumPermutationGroup(length(M.classic),interreduce)

    for relation in relation_indices
        temp = one(A)
        for gen in relation
            temp = temp * u[gen[1], gen[2]]
        end
        push!(relation_transformed,temp)
    end
  
    return relation_transformed,  u, A

end

getMatroidRelations(M::Matroid, structure::Symbol=:bases, interreduce::Bool=false)= getMatroidRelations(MultiSetMatroid(M),structure,interreduce)

